<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <title>Ëá™Âä®Âåñ‰∏ì‰∏öÂ≠¶‰π†Á¨îËÆ∞</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <meta name="description" content="Description">
  <meta name="viewport"
    content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <link rel="icon"
    href="https://avatars.githubusercontent.com/u/64292434?s=400&u=1dae24f4bdc8f8d1e5736cf04147480ca7b1b1a1&v=4"
    type="image/x-icon" />
  <link rel="stylesheet" href="https://cdn.staticfile.org/docsify/4.13.1/themes/vue.css" />
  <link rel="stylesheet" href="https://cdn.staticfile.org/docsify/4.13.1/themes/buble.css" disabled />
  <link rel="stylesheet" href="https://cdn.staticfile.org/docsify/4.13.1/themes/dark.css" disabled />
  <link rel="stylesheet" href="https://cdn.staticfile.org/docsify/4.13.1/themes/pure.css" disabled />
  <style>
    .katex-display {
      overflow-x: auto;
      overflow-y: hidden;
    }
  </style>
</head>

<body>

  <nav>
    <select id="control">
      <optgroup label="‰∏ªÈ¢ò">
        <option value="vue">vue</option>
        <option value="buble">buble</option>
        <option value="dark">ÊöóËâ≤</option>
        <option value="pure">Á∫ØÂáÄ</option>
      </optgroup>
      <optgroup label="Ë∞ÉËØï">
        <option value="clear-cache">Ê∏ÖÁ©∫ÁºìÂ≠ò</option>
      </optgroup>
    </select>
    <a href="#/content.md">ÁõÆÂΩï</a>
  </nav>
  <script>
    //ÂáΩÊï∞ÔºöÊõ¥Êç¢docsify‰∏ªÈ¢ò
    function changeTheme(title) {
      const themes = document.querySelectorAll('head [rel="stylesheet"]');
      localStorage.setItem("docsify.theme", title)
      let all_disabled = true;
      themes.forEach(function (theme) {
        theme.disabled = !theme.href.includes(title);
        all_disabled &= theme.disabled;
      });
      if (all_disabled) {
        console.warn(`the css title ${title} is not a valid one`, themes);
        console.warn(`use first css ${themes[0].href}`);
        themes[0].disabled = false;
      }
    }

    //ÊâãÂä®Êõ¥Êç¢‰∏ªÈ¢ò
    const control = document.getElementById("control")
    control.value = localStorage.getItem("docsify.theme") ?? "vue"
    changeTheme(control.value);
    control.addEventListener(
      "input", e => {
        if (e.target.value === "clear-cache") {
          localStorage.clear()
        } else {
          changeTheme(e.target.value);
        }
      }
    )
  </script>


  <div id="app"></div>
  <script>
    window.$docsify = {
      name: '<span>Â§ßÂ≠¶Á¨îËÆ∞</span>',
      repo: 'https://github.com/xsro/notes',
      coverpage: true,
      onlyCover: false,
      plugins: [
        // https://docsify.js.org/#/write-a-plugin?id=write-a-plugin
        function (hook, vm) {
          hook.init(function () {
            // Called when the script starts running, only trigger once, no arguments,
          });

          hook.beforeEach(function (content) {
            // Invoked each time before parsing the Markdown file.

            // edit on gitee and markmap by https://docsify.js.org/#/write-a-plugin?id=edit-button
            let prefix = document.location.pathname;
            if (!prefix.endsWith("/")) {
              prefix = prefix.substring(0, prefix.lastIndexOf("/") + 1);
            }
            const markmapUrl = new URL(prefix + 'markmap.html', document.location);
            const markdownUrl = new URL(prefix + vm.route.file, document.location);
            markmapUrl.searchParams.set("md", markdownUrl.pathname)
            content = `[üìù EDIT](https://github.com/xsro/notes/edit/main/${vm.route.file})\t`
              + `[üìö VIEW](https://github.com/xsro/notes/blob/main/${vm.route.file})\t`
              + `[üéá MARKMAP](${markmapUrl.href})\n\n` + content;

            return content;
          });

          hook.afterEach(function (html, next) {
            // Invoked each time after the Markdown file is parsed.
            // beforeEach and afterEach support asynchronous„ÄÇ
            // ...
            // call `next(html)` when task is done.
            next(html);
          });

          hook.doneEach(function () {
            // Invoked each time after the data is fully loaded, no arguments,
            // ...
          });

          hook.mounted(function () {
            // Called after initial completion. Only trigger once, no arguments.
            // use gitee corner following https://github.com/Koooooo-7/docsify-corner 
            // const icon = "https://github.com/xsro/notes/widgets/widget_1.svg"
            const a = document.querySelector('a.github-corner')
            a.href = 'https://github.com/xsro/notes'
          });

          hook.ready(function () {
            // Called after initial completion, no arguments.
          });
        }],
      search: {
        maxAge: 1000,
        paths: ["README.md", "content.md"]
      }
    };
  </script>
  <script src="https://cdn.staticfile.org/docsify/4.13.1/docsify.min.js"></script>


  <!-- full text search https://docsify.js.org/#/plugins?id=full-text-search -->
  <script>
    const searchPaths = localStorage.getItem("docsify.search.paths");
    if (searchPaths) {
      window.$docsify.search.paths = JSON.parse(searchPaths);
    }
    async function getFileList() {
      const url = new URL(document.location.href);
      const base = url.pathname.endsWith('/') ? url.pathname : url.pathname.substring(0, url.pathname.lastIndexOf('/') + 1);
      const res = await fetch(base + "all-markdown.md")
      const text = await res.text();
      const files = []
      const regex = /\[([^[\]]*)\]/; // Êó† g Ê†áÂøóÔºå‰ªÖÂåπÈÖçÁ¨¨‰∏ÄÊ¨°
      for (const line of text.split("\n")) {
        const match = line.match(regex);
        if (match) {
          files.push("/" + match[1]);
        }
      }

      localStorage.setItem("docsify.search.paths", JSON.stringify(files));
    }
    getFileList();
  </script>
  <script src="https://cdn.staticfile.org/docsify/4.13.1/plugins/search.min.js"></script>

  <!-- support mermaid following https://docsify.js.org/#/markdown?id=supports-mermaid -->
  <script src="https://cdn.staticfile.org/mermaid/8.13.10/mermaid.min.js"></script>
  <script>
    var num = 0;
    mermaid.initialize({ startOnLoad: false });
    window.$docsify.markdown =
    {
      renderer: {
        code: function (code, lang) {
          if (lang === "mermaid") {
            return (
              '<div class="mermaid">' + mermaid.render('mermaid-svg-' + num++, code) + "</div>"
            );
          }
          return this.origin.code.apply(this, arguments);
        }
      }
    };
  </script>


  <!-- redirect links prefix with ./ -->
  <script>
    function ensureEndsWith(str_, suffix) {
      const str = str_.replace(/[\\\/]+/g, "/"); //remove trailing slashes
      if (str.endsWith(suffix)) {
        return str;
      } else {
        return str.substring(0, str.lastIndexOf(suffix) + 1);
      }
    }

    window.$docsify.plugins.push(
      function (hook, vm) {
        hook.beforeEach(function (content) {
          const prefix1 = ensureEndsWith(document.location.pathname, "/");
          const prefix2 = ensureEndsWith(vm.route.path, "/");
          let prefix = prefix1 + prefix2;
          if (prefix2.startsWith("/")) {
            prefix = prefix1.substring(0, prefix1.length - 1) + prefix2;
          }
          content = content.replace(/\]\(\//g, `](${prefix}`);
          content = content.replace(/\]\(\\/g, `](${prefix}`);
          return content;
        })
      }
    );
  </script>


  <!-- support katex following https://github.com/upupming/docsify-katex#usage-->
  <script defer src="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
  <link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/KaTeX/0.16.9/katex.min.css">
  <script>
    window.$docsify.plugins.push(
      function (hook, vm) {
        let blocks = [];
        hook.beforeEach(function (mdstr) {
          for (const r of mdstr.matchAll(/[^\\]\$\$([\s\S]*?[^\\])\$\$/g)) {
            mdstr = mdstr.replace(r[0], `[math[${blocks.length}]]`)
            blocks.push([r[0], r[1], true])
          }
          for (const r of mdstr.matchAll(/[^\\]\\\[([\s\S]*?[^\\])\\\]/g)) {
            mdstr = mdstr.replace(r[0], `[math[${blocks.length}]]`)
            blocks.push([r[0], r[1], true])
          }
          for (const r of mdstr.matchAll(/\$(.*?[^\\])\$/g)) {
            mdstr = mdstr.replace(r[0], `[math[${blocks.length}]]`)
            blocks.push([r[0], r[1], false])
          }
          for (const r of mdstr.matchAll(/\\\((.*?[^\\])\\\)/g)) {
            mdstr = mdstr.replace(r[0], `[math[${blocks.length}]]`)
            blocks.push([r[0], r[1], false])
          }
          return mdstr
        });
        hook.afterEach(function (html, next) {
          for (const index in blocks) {
            const [full, tex, display] = blocks[index];
            let rendered = ""
            if (typeof katex !== "undefined") {
              try {
                rendered = katex.renderToString(tex, {
                  throwOnError: true,
                  displayMode: display,
                })
              } catch (e) {
                rendered = `<span style="color: red;">${e}</span>`
              }
            } else {
              rendered = `<a title="${full}">[${display ? "block" : "inline"}math[${blocks.length - index}]]</a>`;
            }
            html = html.replace(`[math[${index}]]`, rendered)
          }
          next(html)
        })
      }
    );
  </script>


  <!-- code syntax  https://docsify.js.org/#/language-highlight-->
  <script src="https://cdn.bootcdn.net/ajax/libs/prism/1.26.0/components/prism-nasm.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/prism/1.26.0/components/prism-python.min.js"></script>
  <script src="https://cdn.bootcdn.net/ajax/libs/prism/1.26.0/components/prism-matlab.min.js"></script>
  <script>
    //use nasm as syntax for assembly
    Prism.languages.assembly = Prism.languages.nasm
  </script>

</body>

</html>